"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.buildSpec = void 0;
const methodsOrder = ['GET', 'POST', 'PUT', 'DELETE', 'HEAD', 'PATCH', 'OPTIONS'];
const parametersSections = {
    headers: 'header',
    params: 'path',
    querystring: 'query'
};
function getRouteConfig(r) {
    return r.config ?? {};
}
function parseParameters(instance, schema) {
    const params = [];
    for (const [section, where] of Object.entries(parametersSections)) {
        let specs = schema[section];
        if (specs?.$ref) {
            specs = instance.getSchema(specs.$ref);
        }
        if (typeof specs !== 'object') {
            continue;
        }
        const required = specs.required ?? [];
        for (const name of Object.keys(specs.properties ?? {})) {
            params.push({
                name,
                in: where,
                description: specs.description,
                required: required.includes(name)
            });
        }
    }
    if (params.length === 0) {
        return undefined;
    }
    return params;
}
function parsePayload(schema) {
    return {
        description: schema.description,
        content: {
            'application/x-www-form-urlencoded': {
                schema: schema
            }
        }
    };
}
function parseResponses(responses) {
    const parsed = {};
    for (const [code, originalResponse] of Object.entries(responses)) {
        const { description, $raw, $empty } = originalResponse;
        const spec = { description };
        if ($raw) {
            spec.content = { [$raw]: {} };
        }
        else if (!$empty) {
            spec.content = {
                'application/json': {
                    schema: originalResponse
                }
            };
        }
        parsed[code] = spec;
    }
    return parsed;
}
function cleanSpec(object) {
    const cleaned = {};
    for (const [key, value] of Object.entries(object)) {
        if (key === '$id' || value === null || typeof value === 'undefined') {
            continue;
        }
        if (key === '$ref') {
            return { $ref: value.replace('#', '#/components/schemas/') };
        }
        if (typeof value === 'object' && !Array.isArray(value)) {
            const cleanedValue = cleanSpec(value);
            if (Array.isArray(cleanedValue.type)) {
                cleanedValue.anyOf = cleanedValue.type.map((t) => ({ type: t }));
                delete cleanedValue.type;
            }
            cleaned[key] = cleanedValue;
        }
        else if (Array.isArray(value)) {
            cleaned[key] = value.map((item) => (typeof item === 'object' ? cleanSpec(item) : item));
        }
        else {
            cleaned[key] = value;
        }
    }
    return cleaned;
}
function buildSpec(instance, spec, schemas, routes) {
    if (!('components' in spec)) {
        spec.components = {};
    }
    if (!('schemas' in spec.components)) {
        spec.components.schemas = {};
    }
    if (!('paths' in spec)) {
        spec.paths = {};
    }
    for (const [id, definition] of Object.entries(schemas)) {
        spec.components.schemas[id.replace('#', '')] = definition;
    }
    const apiRoutes = routes
        .filter((r) => getRouteConfig(r).hide !== true)
        .sort((a, b) => a.url.localeCompare(b.url));
    for (const route of apiRoutes) {
        const config = getRouteConfig(route);
        const path = route.url.replace(/:([a-zA-Z_]+)/g, '{$1}');
        if (!spec.paths[path]) {
            spec.paths[path] = {};
        }
        const methods = (Array.isArray(route.method) ? route.method : [route.method]).sort((a, b) => methodsOrder.indexOf(a) - methodsOrder.indexOf(b));
        const { summary, description, tags, security } = config.openapi ?? {};
        for (const method of methods) {
            const schema = route.schema ?? {};
            spec.paths[path][method.toLowerCase()] = {
                summary,
                description,
                tags,
                security,
                parameters: parseParameters(instance, schema),
                responses: 'response' in schema ? parseResponses(schema.response) : undefined,
                requestBody: 'body' in schema && ['PUT', 'PATCH', 'POST'].includes(method)
                    ? parsePayload(schema.body)
                    : undefined
            };
        }
    }
    return cleanSpec(spec);
}
exports.buildSpec = buildSpec;
